package hybrid.nodes;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import hybrid.Client;
import hybrid.Statistics;
import util_objects.Coordinates;
import util_objects.NodeState;
import util_objects.Task;

/**
 * Represents a node.
 * @author Marvin Kruber
 *
 */
public abstract class Node {
	
	//------------------------------------------ Metadata information -------------------------------------------------------
	// Distinguish between static and dynamic metadata information
	/** IP address of the node */
	private final String IP_ADDRESS;
	
	/** Port number of the node */
	private final int PORT;
	
	/** Unique identifier of the node.<br>
	 *  Generated by the {@link Cloud}. */
	private final long NODE_ID;
	
	/** {@link Coordinates} of the node **/
	private final Coordinates COORDINATES;
	
	/** Available storage capacity [in byte] */
	private long availableStorage;
	
	/** Available computation capacity [in byte] */
	private long availableRAM;
	
	/** Stores all completed tasks */
	private List<Task> taskHistory = new ArrayList<>();
	
	/** Help object for locking the storage and computation capacity */
	private Object capacity_Lock;
	
	/** Indicates if a node has failed */
	protected AtomicBoolean hasFailed = new AtomicBoolean(false);
	
	/** {@link Statistics}*/
	protected Statistics stats = Statistics.getInstance();
	
	//------------------------------------------ Cluster information ---------------------------------------------------------------
	
	/** Stores the metadata versions of all nodes in the cluster by their NODE_ID.*/
	protected Map<Long, NodeState> clusterMetaData = new HashMap<Long, NodeState>();
	
	/** {@link GossipThread} instance which handles the gossip communication of the node */
	protected GossipThread gossiper = null;
	
	//------------------------------------------ Stats -----------------------------------------------------------------------------
	/** Number of messages received*/
	protected AtomicInteger msg_received = new AtomicInteger(0);
	
	/** Number of messages send*/
	private AtomicInteger msg_sent = new AtomicInteger(0);
	
	/** Number of messages send*/
	protected AtomicInteger msg_replied = new AtomicInteger(0);
	
	/** ID of the edge pool which contains the node. <br>
	 *  It is 0 if the node is no edge node. */
	protected int pool_ID = 0;
	
	/**
	 * Creates a new node out of static (immutable) metadata information.
	 * @param IP_ADDRESS - IP address of the new node
	 * @param PORT - port number of the new node
	 * @param NODE_ID - ID of the new node
	 * @param COORDINATES - allocation of the new node
	 * @param MAX_STORAGE - maximum storage capacity of the new node [in byte]
	 * @param MAX_RAM - maximum computation capacity of the new node [in byte]
	 */
	public Node(String IP_ADDRESS, int PORT, long NODE_ID, Coordinates COORDINATES, long MAX_STORAGE, long MAX_RAM) {
		this.IP_ADDRESS = IP_ADDRESS;
		this.PORT = PORT;
		this.NODE_ID = NODE_ID;
		this.COORDINATES = COORDINATES;
		this.availableStorage = MAX_STORAGE;
		this.availableRAM = MAX_RAM;
		this.capacity_Lock = new Object();
	}	
	
	/** Shutdowns the node and updates the {@link Statistics}. */
	public void shutdownNode() {
		this.gossiper.interrupt();
		int size = this.taskHistory.size();
		stats.storeNumberOfTasksPerNode(this.NODE_ID, Integer.valueOf(size));
		stats.storeCoordinates(this.NODE_ID, this.COORDINATES);
		stats.storeFailureState(this.NODE_ID, this.hasFailed.get());
		stats.storeNumberOfGossipMsgSent(this.NODE_ID, Integer.valueOf(this.msg_sent.intValue()));
		stats.storeNumberOfGossipMsgReceived(this.NODE_ID, Integer.valueOf(this.msg_received.intValue()));
		stats.storeNumberOfGossipMsgReplied(this.NODE_ID, Integer.valueOf(this.msg_replied.intValue()));
		stats.storeEdgePoolMembership(this.NODE_ID, this.pool_ID);
		double avgExecutionTime = 0;
		double avgTransmissionLatency = 0;
		
		if(size > 0) {
			avgExecutionTime = this.taskHistory.stream()
					.map(x -> x.getExecutionTime()).reduce(0L, ((acc , y) -> acc + y)) / size;
			avgTransmissionLatency = this.taskHistory.stream()
					.map(x -> x.getTransmissionDelay()).reduce(0L, (acc, y) -> acc + y) / size;
		}
		
		stats.storeAvgExecutionTime(this.NODE_ID, avgExecutionTime);
		stats.storeAvgTransmisionLatency(this.NODE_ID, avgTransmissionLatency);
	}
	
	/** Removes node from cluster. */
	public void removeNodeFromCluster(Long NODE_ID) {
		synchronized(this.clusterMetaData) {
			this.clusterMetaData.remove(NODE_ID);
		}
	}
	

	//------------------------------------------------ Task execution --------------------------------------------------------------
	
	/**
	 * Receives a message from the sender node and checks whether the available capacities are sufficient.
	 * If this is fulfilled, it executes the passed task. Otherwise it redirects the task.
	 * @param task - task which should be executed
	 */
	protected void receiveTask(Task task) {
		boolean capacityIsSufficient = this.checkAndProcessTask(task);
		// Redirect the task, if the capacity is not sufficient
		if(!capacityIsSufficient) {
			this.redirectTask(task);
			this.stats.increaseNrOfRedirectedTasks();
		}
	}
	
	/**
	 * Checks whether the available capacities are sufficient for the task.
	 * If this is fulfilled, it executes the passed task.
	 * @param task - task which should be executed
	 * @return whether the capacities are sufficient or not
	 */
	protected boolean checkAndProcessTask(Task task) {
		boolean capacityIsSufficient = false;
		synchronized(this.capacity_Lock) {
			capacityIsSufficient = (this.availableRAM >= task.getRequiredRAM()) && (this.availableStorage >= task.getRequiredStorage());
			if(capacityIsSufficient) {
				this.executeTask(task);
			}
		}
		return capacityIsSufficient;
	}
	
	/**
	 * Processes a redirected task by checking the available resources and executing the task if possible.
	 * @param task - task which should be executed
	 * @return whether there are sufficient capacities or not
	 */
	public boolean checkRedirectedTaskRequest(Task task) {
		return this.checkAndProcessTask(task);
	}
	
	/**
	 * Executes a given task by initiating a new {@link WorkerThread} and decreases the available capacities.
	 * @param task - task which should be performed
	 */
	protected void executeTask(Task task) {
		this.availableRAM -= task.getRequiredRAM();
		this.availableStorage -= task.getRequiredStorage();
		this.gossiper.updateNodeState();
		new WorkerThread(this, task).start();
	}
	
	/**
	 * Completes a task and releases the previous required capacities. Thereby the capacity variables of the node are locked.
	 * @param task - completed task
	 */
	public void completeTask(Task task) {
		synchronized(this.capacity_Lock) {
			this.availableRAM += task.getRequiredRAM();
			this.availableStorage += task.getRequiredStorage();
			this.gossiper.updateNodeState();
			this.taskHistory.add(task);
		}
		//System.out.println("[INFO] - TASK COMPLETED BY: " + this.NODE_ID);
	}
	
	/**
	 * Redirects the task to another node (or to the supervisor).
	 * @param task - task which should be redirected
	 */
	public abstract void redirectTask(Task task);
	
	/**
	 * Sends message to the target node.
	 * @param target - target of the message
	 * @param task- task which should be performed by the target
	 */
	protected void sendTask(Node target, Task task) {
		target.receiveTask(task);
	}
	
	//---   ---   ---   ---   ---   ---   ---   ---   ---   ---  Client ---   ---   ---   ---   ---   ---   ---   ---   ---   --- 
	/**
	 * Receives a message from a client which contains a task and the position of the client.
	 * It processes the task and checks whether there is any closer node.
	 * @param task - task to process
	 * @param clientPosition - geographical position of the client
	 * @return closest node
	 */
	public void receiveTaskFromClient(Task task, Client client) {
		this.receiveTask(task);
		//The contactNode of the client is changed, if there is a closer node
		client.changeContactNode(this.checkForCloserNode(client.getClientPosition()));
	}
	
	/** After a client sent a message, the node checks whether there is any closer node in the system. */
	public abstract Node checkForCloserNode(Coordinates clientPosition);
	
	//------------------------------------------------ Gossip --------------------------------------------------------------
	/** Creates an associated {@link GossipThread} to participate in the gossip communication.
	 * @return the node itself*/
	public Node initiateGossip() {
		if(this.gossiper == null) {
			this.gossiper = new GossipThread(this, this.clusterMetaData);
			this.gossiper.updateNodeState();
			this.gossiper.start();			
		}
		return this;
	}
	
	/**
	 * Simulates the gossip communication. Thereby, all metadata information which differs in terms of currentness
	 * is exchanged between the two nodes.
	 * @param sender - node which initiated the communication
	 * @param receivedMetadata - transmitted metadata information of the sender
	 * @throws NoSuchElementException if a node has failed
	 * @return more current metadata information of the own cluster view
	 */
	public Map<Long, NodeState> receiveAndRespondGossipFrom(Node sender, Map<Long, NodeState> receivedMetadata) throws NoSuchElementException{
		Map<Long, NodeState> reply;
		//Node Failure
		if(this.hasFailed.get()) {
			System.out.println("Throw Exception");
			throw new NoSuchElementException("Node: "+ this.NODE_ID);
		}	
			//Computes differences and add more current metadata information to the own cluster view.
			this.clusterMetaData.putAll(this.determineDifferences(this.clusterMetaData, receivedMetadata));	
			
			//Searches more current metadata information of the own cluster view and returns those to the sender. 
			reply = this.determineDifferences(receivedMetadata, this.clusterMetaData);
		this.msg_received.incrementAndGet();
		this.msg_replied.incrementAndGet();
		return reply;	
	}
	
	/**
	 * Compares the ownMetadata map with the newMetadata map and returns all differences of newMetadata.
	 * @param ownMetadata own metadata information map
	 * @param newMetadata received metadata information map
	 * @return a map of changed (i.e. more current) metadata values
	 */
	private Map<Long, NodeState> determineDifferences(Map<Long, NodeState> ownMetadata, Map<Long, NodeState> newMetadata) {
		return newMetadata.entrySet().stream()
			.filter(x -> (!ownMetadata.containsKey(x.getKey())) || 
					x.getValue().getFields().get("coordinates").getVersion() > ownMetadata.get(x.getKey()).getFields().get("coordinates").getVersion())
			.collect(Collectors.toMap(x -> x.getKey(), y -> y.getValue()));
	}
	
	//------------------------------------------------ Node Failure  --------------------------------------------------------------
	
	/** Simulates a node failure. */
	public void fail() {
		this.hasFailed.set(true);
		this.gossiper.interrupt();
		System.out.println("[ERROR] - NODE FAILURE | NODE: " + this.NODE_ID);
	}
	
	/**
	 * Reports a node failure to the supervisor.
	 * @param failedNode - node which potentially failed
	 * @param NodeID -  ID of the reporting node
	 */
	public abstract void reportNodeFailureToSupervisor(Node failedNode, Long NodeID);
	
	//================================  Getter   ===============================================
	
	/** @return the ID of the node */
	public Long getNodeID() {
		return this.NODE_ID;
	}
	
	/** @return geographical coordinates of the node*/
	public Coordinates getCoordinates() {
		return this.COORDINATES;
	}

	/**@return currently available storage capacity [in byte]*/
	public long getavailableStorage() {
		return this.availableStorage;
	}
	
	/** @return currently available computation capacity [in byte]*/
	public long getavailableRAM() {
		return this.availableRAM;
	}
	
	/** @return the IP address of the node*/
	public String getIPAdress() {
		return this.IP_ADDRESS;
	}
	
	/** @return the port number of the node*/
	public int getPort() {
		return this.PORT;
	}
	
	/** @return currentNodeState */
	public NodeState getNodeState() {
		return this.clusterMetaData.get(this.NODE_ID);
	}
	
	/** @return ID of the current edge pool (0 if it is no edge node)*/
	public int getPoolID() {
		return this.pool_ID;
	}
	
	/** @return if the node is available or not*/
	public boolean isAvailable() {
		return !(this.hasFailed.get());
	}
	
	/** Increases {@link Node#msg_sent} by one */
	public void increaseMsgSent() {
		this.msg_sent.incrementAndGet();
	}
}
